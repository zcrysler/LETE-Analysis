<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Statistical analysis of BTNEP Automated VHF Telemetry Network Project</title>
  <meta name="description" content="Statistical analysis of BTNEP Automated VHF Telemetry Network Project">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="Statistical analysis of BTNEP Automated VHF Telemetry Network Project" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Statistical analysis of BTNEP Automated VHF Telemetry Network Project" />
  
  
  

<meta name="author" content="Zoe Crysler">


<meta name="date" content="2019-07-09">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="DownloadingData.html">
<link rel="next" href="Results.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><strong><a href="./">LETE analysis</a></strong></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Spatial and temporal requirements of breeding Least Terns through the use of Motus automated radio-telemetry data</a></li>
<li class="chapter" data-level="1" data-path="DownloadingData.html"><a href="DownloadingData.html"><i class="fa fa-check"></i><b>1</b> Downloading and Accessing Data</a><ul>
<li class="chapter" data-level="1.1" data-path="DownloadingData.html"><a href="DownloadingData.html#loading-packages"><i class="fa fa-check"></i><b>1.1</b> Loading Packages</a></li>
<li class="chapter" data-level="1.2" data-path="DownloadingData.html"><a href="DownloadingData.html#data-download---project-132"><i class="fa fa-check"></i><b>1.2</b> Data Download - project 132</a></li>
<li class="chapter" data-level="1.3" data-path="DownloadingData.html"><a href="DownloadingData.html#accessing-data"><i class="fa fa-check"></i><b>1.3</b> Accessing Data</a></li>
<li class="chapter" data-level="1.4" data-path="DownloadingData.html"><a href="DownloadingData.html#cleaning-data"><i class="fa fa-check"></i><b>1.4</b> Cleaning Data</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="DataManipulation.html"><a href="DataManipulation.html"><i class="fa fa-check"></i><b>2</b> Data Manipulation</a><ul>
<li class="chapter" data-level="2.1" data-path="DataManipulation.html"><a href="DataManipulation.html#importing-data-if-not-already-loaded"><i class="fa fa-check"></i><b>2.1</b> Importing data if not already loaded</a></li>
<li class="chapter" data-level="2.2" data-path="DataManipulation.html"><a href="DataManipulation.html#importing-nesting-and-tag-retention-data"><i class="fa fa-check"></i><b>2.2</b> Importing Nesting and Tag Retention Data</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="Results.html"><a href="Results.html"><i class="fa fa-check"></i><b>3</b> LETE Results</a><ul>
<li class="chapter" data-level="3.1" data-path="Results.html"><a href="Results.html#study-area"><i class="fa fa-check"></i><b>3.1</b> Study Area</a></li>
<li class="chapter" data-level="3.2" data-path="Results.html"><a href="Results.html#detection-overview"><i class="fa fa-check"></i><b>3.2</b> Detection Overview</a></li>
<li class="chapter" data-level="3.3" data-path="Results.html"><a href="Results.html#foraging-vs-incubating"><i class="fa fa-check"></i><b>3.3</b> Foraging vs Incubating</a></li>
<li class="chapter" data-level="3.4" data-path="Results.html"><a href="Results.html#heavily-frequented-foraging-areas"><i class="fa fa-check"></i><b>3.4</b> Heavily Frequented Foraging Areas</a><ul>
<li class="chapter" data-level="3.4.1" data-path="Results.html"><a href="Results.html#simultaneous-detections"><i class="fa fa-check"></i><b>3.4.1</b> Simultaneous Detections</a></li>
<li class="chapter" data-level="3.4.2" data-path="Results.html"><a href="Results.html#detection-directions"><i class="fa fa-check"></i><b>3.4.2</b> Detection Directions</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="Results.html"><a href="Results.html#mean-distances-travelled-for-foraging"><i class="fa fa-check"></i><b>3.5</b> Mean Distances Travelled for Foraging</a></li>
<li class="chapter" data-level="3.6" data-path="Results.html"><a href="Results.html#time-partitioning-between-foraging-and-nest-site-attendance"><i class="fa fa-check"></i><b>3.6</b> Time Partitioning Between Foraging and Nest Site Attendance</a></li>
</ul></li>
<li class="appendix"><span><b>Appendix</b></span></li>
<li class="chapter" data-level="A" data-path="AppendixA.html"><a href="AppendixA.html"><i class="fa fa-check"></i><b>A</b> Appendix - Distances Between Receivers</a></li>
<li class="chapter" data-level="B" data-path="AppendixB.html"><a href="AppendixB.html"><i class="fa fa-check"></i><b>B</b> Appendix - Site Visits</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Statistical analysis of BTNEP Automated VHF Telemetry Network Project</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="DataManipulation" class="section level1">
<h1><span class="header-section-number">2</span> Data Manipulation</h1>
<div id="importing-data-if-not-already-loaded" class="section level2">
<h2><span class="header-section-number">2.1</span> Importing data if not already loaded</h2>
<p>Since we created filters in the previous section, once those are created we can simply load the pre-filtered data as below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(motus)
proj.num &lt;-<span class="st"> </span><span class="dv">132</span>
sql.motus &lt;-<span class="st"> </span><span class="kw">tagme</span>(<span class="dt">projRecv =</span> proj.num, <span class="dt">new =</span> <span class="ot">FALSE</span>, <span class="dt">update =</span> <span class="ot">FALSE</span>) <span class="co"># could check periodically if more data is expected </span>
tbl.alltags &lt;-<span class="st"> </span><span class="kw">tbl</span>(sql.motus, <span class="st">&quot;alltags&quot;</span>)

<span class="co"># obtain a table object of the filter</span>
tbl.filter =<span class="st"> </span><span class="kw">getRunsFilters</span>(sql.motus, <span class="st">&quot;filtFalsePos&quot;</span>)

<span class="co"># filter and convert the table into a dataframe, with a few modications</span>
lete &lt;-<span class="st"> </span><span class="kw">left_join</span>(tbl.alltags, tbl.filter, <span class="dt">by =</span> <span class="kw">c</span>(<span class="st">&quot;runID&quot;</span>, <span class="st">&quot;motusTagID&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">probability =</span> <span class="kw">ifelse</span>(<span class="kw">is.na</span>(probability), <span class="dv">1</span>, probability),
         <span class="dt">recvLat =</span> <span class="kw">if_else</span>((<span class="kw">is.na</span>(gpsLat)<span class="op">|</span>gpsLat <span class="op">==</span><span class="st"> </span><span class="dv">0</span>), <span class="co"># create new lat/lon variables</span>
                           recvDeployLat, gpsLat), 
         <span class="dt">recvLon =</span> <span class="kw">if_else</span>((<span class="kw">is.na</span>(gpsLon)<span class="op">|</span>gpsLon <span class="op">==</span><span class="st"> </span><span class="dv">0</span>), 
                           recvDeployLon, gpsLon)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(probability <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="co">#remove unecessary columns</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>ambigID, <span class="op">-</span>tagProjID, <span class="op">-</span>sigsd, <span class="op">-</span>noise, <span class="op">-</span>freq, <span class="op">-</span>freqsd, <span class="op">-</span>slop, <span class="op">-</span>burstSlop, <span class="op">-</span>done, <span class="op">-</span>bootnum, <span class="op">-</span>tagType, <span class="op">-</span>codeSet, <span class="op">-</span>mfg, <span class="op">-</span>tagModel, <span class="op">-</span>tagLifespan, <span class="op">-</span>nomFreq, <span class="op">-</span>pulseLen, <span class="op">-</span>markerNumber, <span class="op">-</span>markerType, <span class="op">-</span>tagDeployAlt, <span class="op">-</span>tagDeployComments, <span class="op">-</span>fullID, <span class="op">-</span>recvDeployAlt, <span class="op">-</span>antHeight, <span class="op">-</span>speciesFR, <span class="op">-</span>speciesSci, <span class="op">-</span>speciesGroup, <span class="op">-</span>tagProjName, <span class="op">-</span>gpsAlt, <span class="op">-</span>recvSiteName, <span class="op">-</span>tagBI, <span class="op">-</span>speciesID, <span class="op">-</span>deviceID, <span class="op">-</span>tagDeployID) <span class="op">%&gt;%</span><span class="st">  </span>
<span class="st">  </span><span class="kw">filter</span>(speciesEN <span class="op">==</span><span class="st"> &quot;Least Tern&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># keep only LETE</span>
<span class="st">  </span><span class="kw">collect</span>() <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span>as.data.frame <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># convert tbl to data.frame</span>
<span class="st">  </span><span class="co"># convert times to datetime</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">ts =</span> <span class="kw">as_datetime</span>(ts, <span class="dt">tz =</span> <span class="st">&quot;UTC&quot;</span>, <span class="dt">origin =</span> <span class="st">&quot;1970-01-01&quot;</span>),
         <span class="dt">tagDeployStart =</span> <span class="kw">as_datetime</span>(tagDeployStart, <span class="dt">tz =</span> <span class="st">&quot;UTC&quot;</span>, <span class="dt">origin =</span> <span class="st">&quot;1970-01-01&quot;</span>),
         <span class="dt">tagDeployEnd =</span> <span class="kw">as_datetime</span>(tagDeployEnd, <span class="dt">tz =</span> <span class="st">&quot;UTC&quot;</span>, <span class="dt">origin =</span> <span class="st">&quot;1970-01-01&quot;</span>),
         <span class="dt">year =</span> <span class="kw">year</span>(ts),
         <span class="dt">recvDeployName =</span> <span class="kw">as.factor</span>(recvDeployName),
         <span class="dt">mfgID =</span> <span class="kw">as.numeric</span>(mfgID)) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># get year variable</span>
<span class="st">  </span><span class="kw">arrange</span>(motusTagID, ts)</code></pre></div>
</div>
<div id="importing-nesting-and-tag-retention-data" class="section level2">
<h2><span class="header-section-number">2.2</span> Importing Nesting and Tag Retention Data</h2>
<p>We will import the nesting and tag retention data to determine incubation periods, at the same time converting variables to proper formats.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">nesting &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;./data/LETE Nesting &amp; Tag Retention Data.csv&quot;</span>)
<span class="co"># rename some variables</span>
nesting &lt;-<span class="st"> </span><span class="kw">rename</span>(nesting, <span class="dt">mfgID =</span> <span class="st">&quot;Tag..&quot;</span>, <span class="dt">nestLat =</span> <span class="st">&quot;Latitude&quot;</span>, 
    <span class="dt">nestLon =</span> <span class="st">&quot;Longitude&quot;</span>)
<span class="co"># convert date to proper date format</span>
nesting &lt;-<span class="st"> </span><span class="kw">mutate</span>(nesting, <span class="dt">Date =</span> <span class="kw">as.Date</span>(nesting<span class="op">$</span>Date, 
    <span class="dt">tz =</span> <span class="st">&quot;CDT&quot;</span>), <span class="dt">mfgID =</span> <span class="kw">as.character</span>(mfgID))
<span class="co"># tags 132 and 120 are recorded together, need to</span>
<span class="co"># separate</span>
tag132 &lt;-<span class="st"> </span><span class="kw">filter</span>(nesting, mfgID <span class="op">==</span><span class="st"> &quot;132 &amp; 120&quot;</span>)
tag132<span class="op">$</span>mfgID &lt;-<span class="st"> </span><span class="kw">ifelse</span>(tag132<span class="op">$</span>mfgID <span class="op">==</span><span class="st"> &quot;132 &amp; 120&quot;</span>, 
    <span class="st">&quot;132&quot;</span>, <span class="st">&quot;&quot;</span>)
nesting<span class="op">$</span>mfgID &lt;-<span class="st"> </span><span class="kw">ifelse</span>(nesting<span class="op">$</span>mfgID <span class="op">==</span><span class="st"> &quot;132 &amp; 120&quot;</span>, 
    <span class="st">&quot;120&quot;</span>, nesting<span class="op">$</span>mfgID)
nesting &lt;-<span class="st"> </span><span class="kw">rbind</span>(tag132, nesting)</code></pre></div>
<p>To determine incubation period, each tag was assigned an end date based on the “Fate” variable, once a nest was categorized as either “failed nest”, “successful nest”, or “eggs due to hatch but no chicks found”, it was assigned an end date of that day; the “nestEnd” variable.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get dataframe of nest end dates</span>
nestEnd &lt;-<span class="st"> </span><span class="kw">filter</span>(nesting, <span class="kw">is.na</span>(Fate) <span class="op">==</span><span class="st"> </span><span class="ot">FALSE</span> <span class="op">&amp;</span><span class="st"> </span>mfgID <span class="op">!=</span><span class="st"> </span>
<span class="st">    &quot;&quot;</span>)
nestEnd &lt;-<span class="st"> </span><span class="kw">select</span>(nestEnd, mfgID, Date)
nestEnd &lt;-<span class="st"> </span><span class="kw">rename</span>(nestEnd, <span class="dt">nestEnd =</span> <span class="st">&quot;Date&quot;</span>)
<span class="co"># get dataframe of tag loss dates</span>
tagLoss &lt;-<span class="st"> </span><span class="kw">filter</span>(nesting, Tag.Status <span class="op">==</span><span class="st"> </span><span class="dv">2</span>)
tagLoss &lt;-<span class="st"> </span>tagLoss <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(mfgID) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">summarize</span>(<span class="dt">tagLoss =</span> <span class="kw">min</span>(Date)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">as.data.frame</span>()
tagLoss<span class="op">$</span>mfgID &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(tagLoss<span class="op">$</span>mfgID)
tags &lt;-<span class="st"> </span><span class="kw">unique</span>(<span class="kw">select</span>(nesting, mfgID))
tags<span class="op">$</span>mfgID &lt;-<span class="st"> </span><span class="kw">as.character</span>(tags<span class="op">$</span>mfgID)
tags<span class="op">$</span>mfgID &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(tags<span class="op">$</span>mfgID)
tagLoss &lt;-<span class="st"> </span><span class="kw">left_join</span>(tags, tagLoss)
tagLoss<span class="op">$</span>tagLoss[<span class="kw">is.na</span>(tagLoss<span class="op">$</span>tagLoss)] &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="st">&quot;2019-01-01&quot;</span>)
tagLoss &lt;-<span class="st"> </span>tagLoss[<span class="op">!</span><span class="kw">is.na</span>(tagLoss<span class="op">$</span>mfgID), ]
<span class="co"># join nest end dates to nesting dataframe</span>
nesting &lt;-<span class="st"> </span><span class="kw">left_join</span>(<span class="kw">select</span>(nesting, mfgID, Nest_ID, 
    nestLat, nestLon, Fate), nestEnd, <span class="dt">by =</span> <span class="st">&quot;mfgID&quot;</span>)
nesting &lt;-<span class="st"> </span><span class="kw">unique</span>(<span class="kw">filter</span>(nesting, mfgID <span class="op">!=</span><span class="st"> &quot;&quot;</span>, <span class="kw">is.na</span>(Fate) <span class="op">==</span><span class="st"> </span>
<span class="st">    </span><span class="ot">FALSE</span>))
nesting<span class="op">$</span>mfgID &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(nesting<span class="op">$</span>mfgID)
<span class="co"># join tagLoss to nesting dataframe</span>
nesting &lt;-<span class="st"> </span><span class="kw">left_join</span>(nesting, tagLoss)
<span class="co"># join with lete database</span>
lete &lt;-<span class="st"> </span><span class="kw">left_join</span>(lete, nesting, <span class="dt">by =</span> <span class="st">&quot;mfgID&quot;</span>)
<span class="co"># remove any detections after tag fell off</span>
lete &lt;-<span class="st"> </span><span class="kw">filter</span>(lete, ts <span class="op">&lt;</span><span class="st"> </span>tagLoss)
<span class="co"># label as incubating or not</span>
lete<span class="op">$</span>incubate &lt;-<span class="st"> </span><span class="kw">ifelse</span>(<span class="kw">as.Date</span>(lete<span class="op">$</span>ts) <span class="op">&lt;=</span><span class="st"> </span>lete<span class="op">$</span>nestEnd, 
    <span class="st">&quot;TRUE&quot;</span>, <span class="st">&quot;FALSE&quot;</span>)
<span class="co"># Tags 114 and 316 do not have incubation</span>
<span class="co"># information and will be set to FALSE</span>
lete<span class="op">$</span>incubate &lt;-<span class="st"> </span><span class="kw">ifelse</span>(lete<span class="op">$</span>mfgID <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">114</span>, <span class="dv">316</span>), 
    <span class="st">&quot;FALSE&quot;</span>, lete<span class="op">$</span>incubate)</code></pre></div>
<p>Determine sunrise and sunset times for each detection based on deteciton location</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lete &lt;-<span class="st"> </span><span class="kw">sunRiseSet</span>(lete, <span class="dt">lat =</span> <span class="st">&quot;recvLat&quot;</span>, <span class="dt">lon =</span> <span class="st">&quot;recvLon&quot;</span>)</code></pre></div>
<p>Only detections that occurred during incubation will be kept, note that tags 114 and 316 do not have incubation information and will thus be excluded.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">inc &lt;-<span class="st"> </span><span class="kw">filter</span>(lete, incubate <span class="op">==</span><span class="st"> </span><span class="ot">TRUE</span>)</code></pre></div>
<p>Examine how long each tag was detected for during incubation</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">detDate &lt;-<span class="st"> </span>inc <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(year, motusTagID, mfgID) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">summarize</span>(<span class="dt">mints =</span> <span class="kw">min</span>(ts), <span class="dt">maxts =</span> <span class="kw">max</span>(ts), <span class="dt">range =</span> <span class="kw">difftime</span>(maxts, 
        mints, <span class="dt">units =</span> <span class="st">&quot;days&quot;</span>), <span class="dt">nSites =</span> <span class="kw">length</span>(<span class="kw">unique</span>(recvDeployName)))
<span class="co"># some birds not detected for very long, lets only</span>
<span class="co"># look at ones detected for at least 1 full day</span>
tmp &lt;-<span class="st"> </span><span class="kw">unique</span>(<span class="kw">filter</span>(detDate, range <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>)<span class="op">$</span>motusTagID)
inc &lt;-<span class="st"> </span><span class="kw">filter</span>(inc, motusTagID <span class="op">%in%</span><span class="st"> </span>tmp)</code></pre></div>
<p>Get a small data frame (lete.path) of hourly detections for easier data manipulation</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Hourly detections</span>
fun.getpath &lt;-<span class="st"> </span><span class="cf">function</span>(df) {
    <span class="kw">mutate</span>(df, <span class="dt">ts.h =</span> <span class="kw">as.POSIXct</span>(<span class="kw">round</span>(ts, <span class="st">&quot;hours&quot;</span>))) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">        </span><span class="kw">group_by</span>(year, motusTagID, runID, ts.h, recvDeployName, 
            recv, tagDeployLon, tagDeployLat, recvLat, 
            recvLon, incubate) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">summarize</span>(<span class="dt">max.runLen =</span> <span class="kw">max</span>(runLen), 
        <span class="dt">tot.runLen =</span> <span class="kw">sum</span>(runLen)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(motusTagID, 
        ts.h) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">data.frame</span>()
}  <span class="co"># end of function call</span>

lete.path &lt;-<span class="st"> </span><span class="kw">fun.getpath</span>(<span class="kw">filter</span>(inc, incubate <span class="op">==</span><span class="st"> </span><span class="ot">TRUE</span>))</code></pre></div>
<p>Create dataframes of 2017 and 2018 active receivers during tagging period</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## list of active receivers find active periods for
## 2017 and 2018
<span class="kw">range</span>(<span class="kw">filter</span>(lete, year <span class="op">==</span><span class="st"> &quot;2017&quot;</span>)<span class="op">$</span>ts)</code></pre></div>
<pre><code>## [1] &quot;2017-05-16 08:23:27 UTC&quot; &quot;2017-08-02 12:29:48 UTC&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">range</span>(<span class="kw">filter</span>(lete, year <span class="op">==</span><span class="st"> &quot;2018&quot;</span>)<span class="op">$</span>ts)</code></pre></div>
<pre><code>## [1] &quot;2018-05-10 12:00:41 UTC&quot; &quot;2018-08-10 10:15:19 UTC&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get receiver metadata</span>
tbl.recvDeps &lt;-<span class="st"> </span><span class="kw">tbl</span>(sql.motus, <span class="st">&quot;recvDeps&quot;</span>)
df.recvDeps &lt;-<span class="st"> </span>tbl.recvDeps <span class="op">%&gt;%</span><span class="st"> </span>collect <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">as.data.frame</span>() <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">mutate</span>(<span class="dt">tsStart =</span> <span class="kw">as_datetime</span>(tsStart, <span class="dt">tz =</span> <span class="st">&quot;UTC&quot;</span>, 
        <span class="dt">origin =</span> <span class="st">&quot;1970-01-01&quot;</span>), <span class="dt">tsEnd =</span> <span class="kw">as_datetime</span>(tsEnd, 
        <span class="dt">tz =</span> <span class="st">&quot;UTC&quot;</span>, <span class="dt">origin =</span> <span class="st">&quot;1970-01-01&quot;</span>))
<span class="co"># for deployments with no end dates, make an end</span>
<span class="co"># date a year from now</span>
df.recvDeps<span class="op">$</span>tsEnd &lt;-<span class="st"> </span><span class="kw">as.POSIXct</span>(<span class="kw">ifelse</span>(<span class="kw">is.na</span>(df.recvDeps<span class="op">$</span>tsEnd), 
    <span class="kw">as.POSIXct</span>(<span class="kw">format</span>(<span class="kw">Sys.time</span>(), <span class="st">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)) <span class="op">+</span><span class="st"> </span>
<span class="st">        </span>lubridate<span class="op">::</span><span class="kw">dyears</span>(<span class="dv">1</span>), df.recvDeps<span class="op">$</span>tsEnd), <span class="dt">tz =</span> <span class="st">&quot;UTC&quot;</span>, 
    <span class="dt">origin =</span> <span class="st">&quot;1970-01-01&quot;</span>)
<span class="co"># get running intervals for all receiver</span>
<span class="co"># deployments</span>
siteOp &lt;-<span class="st"> </span><span class="kw">with</span>(df.recvDeps, lubridate<span class="op">::</span><span class="kw">interval</span>(tsStart, 
    tsEnd))  <span class="co"># get running intervals for each deployment</span>
<span class="co"># set the date range you&#39;re interested in</span>
dateRange17 &lt;-<span class="st"> </span>lubridate<span class="op">::</span><span class="kw">interval</span>(<span class="kw">as.POSIXct</span>(<span class="st">&quot;2017-05-15&quot;</span>), 
    <span class="kw">as.POSIXct</span>(<span class="st">&quot;2017-07-04&quot;</span>))
dateRange18 &lt;-<span class="st"> </span>lubridate<span class="op">::</span><span class="kw">interval</span>(<span class="kw">as.POSIXct</span>(<span class="st">&quot;2018-05-08&quot;</span>), 
    <span class="kw">as.POSIXct</span>(<span class="st">&quot;2018-07-10&quot;</span>))
<span class="co"># create new variable &#39;active&#39; which will be set to</span>
<span class="co"># TRUE if the receiver was active at some point</span>
<span class="co"># during your specified date range, and FALSE if</span>
<span class="co"># not</span>
df.recvDeps17 &lt;-<span class="st"> </span>df.recvDeps
df.recvDeps17<span class="op">$</span>active17 &lt;-<span class="st"> </span>lubridate<span class="op">::</span><span class="kw">int_overlaps</span>(siteOp, 
    dateRange17)
df.recvDeps17 &lt;-<span class="st"> </span><span class="kw">select</span>(df.recvDeps17, serno, name, 
    active17, latitude, longitude)
df.recvDeps18 &lt;-<span class="st"> </span>df.recvDeps
df.recvDeps18<span class="op">$</span>active18 &lt;-<span class="st"> </span>lubridate<span class="op">::</span><span class="kw">int_overlaps</span>(siteOp, 
    dateRange18)
df.recvDeps18 &lt;-<span class="st"> </span><span class="kw">select</span>(df.recvDeps18, serno, name, 
    active18, latitude, longitude)
<span class="co"># combined data frame showing when each was active</span>
df.recvDepsCombined &lt;-<span class="st"> </span><span class="kw">left_join</span>(<span class="kw">filter</span>(df.recvDeps17, 
    active17 <span class="op">==</span><span class="st"> </span><span class="ot">TRUE</span>), <span class="kw">filter</span>(df.recvDeps18, active18 <span class="op">==</span><span class="st"> </span>
<span class="st">    </span><span class="ot">TRUE</span>))
df.recvDepsCombined<span class="op">$</span>active18 &lt;-<span class="st"> </span><span class="kw">ifelse</span>(<span class="kw">is.na</span>(df.recvDepsCombined<span class="op">$</span>active18), 
    <span class="st">&quot;FALSE&quot;</span>, df.recvDepsCombined<span class="op">$</span>active18)
df.recvDepsCombined<span class="op">$</span>active &lt;-<span class="st"> </span>df.recvDepsCombined<span class="op">$</span>active18
df.recvDepsCombined &lt;-<span class="st"> </span><span class="kw">rename</span>(df.recvDepsCombined, 
    <span class="dt">recvDeployName =</span> <span class="st">&quot;name&quot;</span>, <span class="dt">recv =</span> <span class="st">&quot;serno&quot;</span>)
<span class="co"># combine with lete detections for mapping later</span>
tmp &lt;-<span class="st"> </span><span class="kw">unique</span>(<span class="kw">select</span>(lete.path, recvDeployName, recv, 
    incubate))
tmp &lt;-<span class="st"> </span><span class="kw">filter</span>(tmp, incubate <span class="op">==</span><span class="st"> </span><span class="ot">TRUE</span>)
df.recvDepsCombined &lt;-<span class="st"> </span><span class="kw">left_join</span>(df.recvDepsCombined, 
    tmp)</code></pre></div>
<p>Create a dataframe with distances between each receiver</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## first create latLonDist function: translated
## from:
## http://www.movable-type.co.uk/scripts/latlong-vincenty.html
## /* - - - - - - - - - - - - - - - - - - - - - - -
## - - - - - - - - - - - - - - - - - - - - - - - -
## */ /* Vincenty Inverse Solution of Geodesics on
## the Ellipsoid (c) Chris Veness 2002-2012 */ /* */
## /* from: Vincenty inverse formula - T Vincenty,
## &#39;Direct and Inverse Solutions of Geodesics on the
## */ /* Ellipsoid with application of nested
## equations&#39;, Survey Review, vol XXII no 176, 1975
## */ /*
## http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf */
## /* - - - - - - - - - - - - - - - - - - - - - - -
## - - - - - - - - - - - - - - - - - - - - - - - -
## */

## /** * Calculates geodetic distance between two
## points specified by latitude/longitude using *
## Vincenty inverse formula for ellipsoids * *
## @param {Number} lat1, lon1: first point in
## decimal degrees * @param {Number} lat2, lon2:
## second point in decimal degrees * @returns
## (Number} distance in metres between points */

latLonDist =<span class="st"> </span><span class="cf">function</span>(lat1, lon1, lat2, lon2) {
    a =<span class="st"> </span><span class="dv">6378137</span>
    b =<span class="st"> </span><span class="fl">6356752.314245</span>
    f =<span class="st"> </span><span class="dv">1</span><span class="op">/</span><span class="fl">298.257223563</span>  ## WGS-84 ellipsoid params
    
    llmat =<span class="st"> </span><span class="kw">cbind</span>(lat1, lon1, lat2, lon2)  ## recycles coordinates to match
    
    s =<span class="st"> </span><span class="kw">rep</span>(<span class="op">-</span><span class="dv">1</span>, <span class="kw">nrow</span>(llmat))  ## return values; -1 means not yet computed
    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(llmat)) {
        ## calculate distance between i&#39;th pair of points
        <span class="cf">if</span> (<span class="op">!</span><span class="kw">all</span>(<span class="kw">is.finite</span>(llmat[i, ]))) {
            s[i] =<span class="st"> </span><span class="ot">NA</span>
            <span class="cf">next</span>
        }
        
        L =<span class="st"> </span><span class="kw">rad</span>(llmat[i, <span class="dv">4</span>] <span class="op">-</span><span class="st"> </span>llmat[i, <span class="dv">2</span>])
        U1 =<span class="st"> </span><span class="kw">atan</span>((<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>f) <span class="op">*</span><span class="st"> </span><span class="kw">tan</span>(<span class="kw">rad</span>(llmat[i, <span class="dv">1</span>])))
        U2 =<span class="st"> </span><span class="kw">atan</span>((<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>f) <span class="op">*</span><span class="st"> </span><span class="kw">tan</span>(<span class="kw">rad</span>(llmat[i, <span class="dv">3</span>])))
        sinU1 =<span class="st"> </span><span class="kw">sin</span>(U1)
        cosU1 =<span class="st"> </span><span class="kw">cos</span>(U1)
        sinU2 =<span class="st"> </span><span class="kw">sin</span>(U2)
        cosU2 =<span class="st"> </span><span class="kw">cos</span>(U2)
        lambda =<span class="st"> </span>L
        iterLimit =<span class="st"> </span><span class="dv">100</span>
        <span class="cf">repeat</span> {
            sinLambda =<span class="st"> </span><span class="kw">sin</span>(lambda)
            cosLambda =<span class="st"> </span><span class="kw">cos</span>(lambda)
            sinSigma =<span class="st"> </span><span class="kw">sqrt</span>((cosU2 <span class="op">*</span><span class="st"> </span>sinLambda) <span class="op">*</span><span class="st"> </span>(cosU2 <span class="op">*</span><span class="st"> </span>
<span class="st">                </span>sinLambda) <span class="op">+</span><span class="st"> </span>(cosU1 <span class="op">*</span><span class="st"> </span>sinU2 <span class="op">-</span><span class="st"> </span>sinU1 <span class="op">*</span><span class="st"> </span>
<span class="st">                </span>cosU2 <span class="op">*</span><span class="st"> </span>cosLambda) <span class="op">*</span><span class="st"> </span>(cosU1 <span class="op">*</span><span class="st"> </span>sinU2 <span class="op">-</span><span class="st"> </span>
<span class="st">                </span>sinU1 <span class="op">*</span><span class="st"> </span>cosU2 <span class="op">*</span><span class="st"> </span>cosLambda))
            <span class="cf">if</span> (<span class="kw">abs</span>(sinSigma) <span class="op">&lt;</span><span class="st"> </span><span class="fl">1e-10</span>) {
                s[i] =<span class="st"> </span><span class="dv">0</span>  ## co-incident points
                <span class="cf">break</span>
            }
            cosSigma =<span class="st"> </span>sinU1 <span class="op">*</span><span class="st"> </span>sinU2 <span class="op">+</span><span class="st"> </span>cosU1 <span class="op">*</span><span class="st"> </span>cosU2 <span class="op">*</span><span class="st"> </span>
<span class="st">                </span>cosLambda
            sigma =<span class="st"> </span><span class="kw">atan2</span>(sinSigma, cosSigma)
            sinAlpha =<span class="st"> </span>cosU1 <span class="op">*</span><span class="st"> </span>cosU2 <span class="op">*</span><span class="st"> </span>sinLambda<span class="op">/</span>sinSigma
            cosSqAlpha =<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span>sinAlpha <span class="op">*</span><span class="st"> </span>sinAlpha
            cos2SigmaM =<span class="st"> </span>cosSigma <span class="op">-</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>sinU1 <span class="op">*</span><span class="st"> </span>sinU2<span class="op">/</span>cosSqAlpha
            <span class="cf">if</span> (<span class="kw">is.nan</span>(cos2SigmaM)) 
                cos2SigmaM =<span class="st"> </span><span class="dv">0</span>  ## equatorial line: cosSqAlpha=0 (§6)
            C =<span class="st"> </span>f<span class="op">/</span><span class="dv">16</span> <span class="op">*</span><span class="st"> </span>cosSqAlpha <span class="op">*</span><span class="st"> </span>(<span class="dv">4</span> <span class="op">+</span><span class="st"> </span>f <span class="op">*</span><span class="st"> </span>(<span class="dv">4</span> <span class="op">-</span><span class="st"> </span><span class="dv">3</span> <span class="op">*</span><span class="st"> </span>
<span class="st">                </span>cosSqAlpha))
            lambdaP =<span class="st"> </span>lambda
            lambda =<span class="st"> </span>L <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>C) <span class="op">*</span><span class="st"> </span>f <span class="op">*</span><span class="st"> </span>sinAlpha <span class="op">*</span><span class="st"> </span>(sigma <span class="op">+</span><span class="st"> </span>
<span class="st">                </span>C <span class="op">*</span><span class="st"> </span>sinSigma <span class="op">*</span><span class="st"> </span>(cos2SigmaM <span class="op">+</span><span class="st"> </span>C <span class="op">*</span><span class="st"> </span>cosSigma <span class="op">*</span><span class="st"> </span>
<span class="st">                  </span>(<span class="op">-</span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>cos2SigmaM <span class="op">*</span><span class="st"> </span>cos2SigmaM)))
            iterLimit =<span class="st"> </span>iterLimit <span class="op">-</span><span class="st"> </span><span class="dv">1</span>
            <span class="cf">if</span> (<span class="kw">abs</span>(lambda <span class="op">-</span><span class="st"> </span>lambdaP) <span class="op">&lt;=</span><span class="st"> </span><span class="fl">1e-12</span> <span class="op">||</span><span class="st"> </span>iterLimit <span class="op">==</span><span class="st"> </span>
<span class="st">                </span><span class="dv">0</span>) 
                <span class="cf">break</span>
        }
        
        <span class="cf">if</span> (iterLimit <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) {
            s[i] =<span class="st"> </span><span class="ot">NaN</span>  ## formula failed to converge
        } <span class="cf">else</span> <span class="cf">if</span> (s[i] <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span>) {
            uSq =<span class="st"> </span>cosSqAlpha <span class="op">*</span><span class="st"> </span>(a <span class="op">*</span><span class="st"> </span>a <span class="op">-</span><span class="st"> </span>b <span class="op">*</span><span class="st"> </span>b)<span class="op">/</span>(b <span class="op">*</span><span class="st"> </span>
<span class="st">                </span>b)
            A =<span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>uSq<span class="op">/</span><span class="dv">16384</span> <span class="op">*</span><span class="st"> </span>(<span class="dv">4096</span> <span class="op">+</span><span class="st"> </span>uSq <span class="op">*</span><span class="st"> </span>(<span class="op">-</span><span class="dv">768</span> <span class="op">+</span><span class="st"> </span>
<span class="st">                </span>uSq <span class="op">*</span><span class="st"> </span>(<span class="dv">320</span> <span class="op">-</span><span class="st"> </span><span class="dv">175</span> <span class="op">*</span><span class="st"> </span>uSq)))
            B =<span class="st"> </span>uSq<span class="op">/</span><span class="dv">1024</span> <span class="op">*</span><span class="st"> </span>(<span class="dv">256</span> <span class="op">+</span><span class="st"> </span>uSq <span class="op">*</span><span class="st"> </span>(<span class="op">-</span><span class="dv">128</span> <span class="op">+</span><span class="st"> </span>uSq <span class="op">*</span><span class="st"> </span>
<span class="st">                </span>(<span class="dv">74</span> <span class="op">-</span><span class="st"> </span><span class="dv">47</span> <span class="op">*</span><span class="st"> </span>uSq)))
            deltaSigma =<span class="st"> </span>B <span class="op">*</span><span class="st"> </span>sinSigma <span class="op">*</span><span class="st"> </span>(cos2SigmaM <span class="op">+</span><span class="st"> </span>
<span class="st">                </span>B<span class="op">/</span><span class="dv">4</span> <span class="op">*</span><span class="st"> </span>(cosSigma <span class="op">*</span><span class="st"> </span>(<span class="op">-</span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>cos2SigmaM <span class="op">*</span><span class="st"> </span>
<span class="st">                  </span>cos2SigmaM) <span class="op">-</span><span class="st"> </span>B<span class="op">/</span><span class="dv">6</span> <span class="op">*</span><span class="st"> </span>cos2SigmaM <span class="op">*</span><span class="st"> </span>
<span class="st">                  </span>(<span class="op">-</span><span class="dv">3</span> <span class="op">+</span><span class="st"> </span><span class="dv">4</span> <span class="op">*</span><span class="st"> </span>sinSigma <span class="op">*</span><span class="st"> </span>sinSigma) <span class="op">*</span><span class="st"> </span>
<span class="st">                  </span>(<span class="op">-</span><span class="dv">3</span> <span class="op">+</span><span class="st"> </span><span class="dv">4</span> <span class="op">*</span><span class="st"> </span>cos2SigmaM <span class="op">*</span><span class="st"> </span>cos2SigmaM)))
            s[i] =<span class="st"> </span>b <span class="op">*</span><span class="st"> </span>A <span class="op">*</span><span class="st"> </span>(sigma <span class="op">-</span><span class="st"> </span>deltaSigma)
        }
    }
    s =<span class="st"> </span><span class="kw">round</span>(s, <span class="dv">3</span>)
    <span class="kw">return</span>(s)
}

## convert to radians from degrees
rad =<span class="st"> </span><span class="cf">function</span>(x) {
    <span class="kw">return</span>(x <span class="op">*</span><span class="st"> </span>(pi<span class="op">/</span><span class="dv">180</span>))
}
## Distances
dist &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">recvDeployName1 =</span> <span class="kw">unique</span>(lete<span class="op">$</span>recvDeployName), 
    <span class="dt">recvDeployName2 =</span> <span class="kw">unique</span>(lete<span class="op">$</span>recvDeployName))
dist &lt;-<span class="st"> </span><span class="kw">unique</span>(<span class="kw">left_join</span>(dist, <span class="kw">select</span>(lete, recvDeployName, 
    recvLat, recvLon), <span class="dt">by =</span> <span class="kw">c</span>(<span class="dt">recvDeployName1 =</span> <span class="st">&quot;recvDeployName&quot;</span>)))
dist &lt;-<span class="st"> </span><span class="kw">rename</span>(dist, <span class="dt">recvLat1 =</span> <span class="st">&quot;recvLat&quot;</span>, <span class="dt">recvLon1 =</span> <span class="st">&quot;recvLon&quot;</span>)
dist &lt;-<span class="st"> </span><span class="kw">unique</span>(<span class="kw">left_join</span>(dist, <span class="kw">select</span>(lete, recvDeployName, 
    recvLat, recvLon), <span class="dt">by =</span> <span class="kw">c</span>(<span class="dt">recvDeployName2 =</span> <span class="st">&quot;recvDeployName&quot;</span>)))
dist &lt;-<span class="st"> </span><span class="kw">rename</span>(dist, <span class="dt">recvLat2 =</span> <span class="st">&quot;recvLat&quot;</span>, <span class="dt">recvLon2 =</span> <span class="st">&quot;recvLon&quot;</span>)
<span class="co"># Get distance (m) between site combos get mean</span>
<span class="co"># lat/lon</span>
dist &lt;-<span class="st"> </span>dist <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(recvDeployName1, recvDeployName2) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">summarize</span>(<span class="dt">recvLat1 =</span> <span class="kw">mean</span>(recvLat1), <span class="dt">recvLon1 =</span> <span class="kw">mean</span>(recvLon1), 
        <span class="dt">recvLat2 =</span> <span class="kw">mean</span>(recvLat2), <span class="dt">recvLon2 =</span> <span class="kw">mean</span>(recvLon2)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span>as.data.frame
dist<span class="op">$</span>distance &lt;-<span class="st"> </span><span class="kw">with</span>(dist, <span class="kw">latLonDist</span>(recvLat1, recvLon1, 
    recvLat2, recvLon2))
<span class="kw">write.csv</span>(dist, <span class="dt">file =</span> <span class="st">&quot;./data/distances.csv&quot;</span>)</code></pre></div>
<p>Create a dataframe for “visits” to each receiver. A visit is categorized as a period of consecutive detections (in minutes) at one station, or multiple periods of consecutive detections at one station where there are fewer that 10 minutes between consecutive periods of detection. Appears as though detections with signal strength &lt;80 at Exxon Fields could be incubation, so for visits we’ll remove those.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># we&#39;ll consider birds to be at the nest anytime</span>
<span class="co"># they are detected with a signal strength below 80</span>
<span class="co"># at Exxon Fields, thus foraging will be:</span>
foraging &lt;-<span class="st"> </span><span class="kw">filter</span>(inc, <span class="op">!</span>(recvDeployName <span class="op">==</span><span class="st"> &quot;Exxon Fields&quot;</span> <span class="op">&amp;</span><span class="st"> </span>
<span class="st">    </span>sig <span class="op">&lt;</span><span class="st"> </span><span class="dv">80</span>))
<span class="co"># rounding lat/lons</span>
foraging &lt;-<span class="st"> </span>foraging <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(recvDeployName) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">mutate</span>(<span class="dt">recvLat =</span> <span class="kw">mean</span>(recvLat), <span class="dt">recvLon =</span> <span class="kw">mean</span>(recvLon), 
        <span class="dt">recvLat =</span> <span class="kw">mean</span>(recvLat), <span class="dt">recvLon =</span> <span class="kw">mean</span>(recvLon)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span>as.data.frame

## look at foraging detections
visits &lt;-<span class="st"> </span>foraging <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(motusTagID, mfgID, 
    recvDeployName, recvDeployID, runID, batchID, year) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">summarize</span>(<span class="dt">mints =</span> <span class="kw">min</span>(ts), <span class="dt">maxts =</span> <span class="kw">max</span>(ts), <span class="dt">numHits =</span> <span class="kw">length</span>(motusTagID))
visits &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(visits)
visits &lt;-<span class="st"> </span>visits[<span class="kw">with</span>(visits, <span class="kw">order</span>(motusTagID, mints)), 
    ]
visits &lt;-<span class="st"> </span>visits <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">diffsec =</span> <span class="kw">as.numeric</span>(mints) <span class="op">-</span><span class="st"> </span>
<span class="st">    </span><span class="kw">lag</span>(<span class="kw">as.numeric</span>(maxts)), <span class="dt">diffmin =</span> <span class="kw">as.numeric</span>(diffsec<span class="op">/</span><span class="dv">60</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span>as.data.frame
## assign a group number for each group of hits at a
## station per tag by time
visits &lt;-<span class="st"> </span>visits[<span class="kw">with</span>(visits, <span class="kw">order</span>(motusTagID, mints)), 
    ]  ## first make sure it&#39;s ordered correctly
<span class="co"># visits$count1 &lt;-</span>
<span class="co"># cumsum(c(0,as.numeric(diff(as.factor(visits$recvDeployName)))!=0))</span>
visits &lt;-<span class="st"> </span>visits <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(motusTagID) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">count1 =</span> <span class="kw">cumsum</span>(<span class="kw">c</span>(<span class="dv">1</span>, 
    <span class="kw">as.numeric</span>(<span class="kw">diff</span>(<span class="kw">as.factor</span>(recvDeployName))) <span class="op">!=</span><span class="st"> </span>
<span class="st">        </span><span class="dv">0</span>)))  ## assign a group number each time the time difference from one runID to another is &gt; 10
visits &lt;-<span class="st"> </span>visits[<span class="kw">with</span>(visits, <span class="kw">order</span>(motusTagID, mints)), 
    ]  ## first make sure it&#39;s ordered correctly
visits<span class="op">$</span>diffmin[<span class="kw">is.na</span>(visits<span class="op">$</span>diffmin)] &lt;-<span class="st"> </span><span class="dv">0</span>  ## set NA in time differences to 0
<span class="co"># visits$count2 &lt;-</span>
<span class="co"># cumsum(c(0,as.numeric(diff(visits$diffmin))&gt;=5))</span>
visits &lt;-<span class="st"> </span>visits <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(motusTagID, count1) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">mutate</span>(<span class="dt">count2 =</span> <span class="kw">c</span>(<span class="kw">cumsum</span>(diffmin <span class="op">&gt;</span><span class="st"> </span><span class="dv">10</span>)), <span class="dt">visitID =</span> <span class="kw">paste</span>(count1, 
        count2, <span class="dt">sep =</span> <span class="st">&quot;.&quot;</span>))  ## now get one value to number each variable

## now lets get the total time for each &#39;visit&#39;
visits &lt;-<span class="st"> </span>visits <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(motusTagID, mfgID, recvDeployName, 
    recvDeployID, visitID, year) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">summarize</span>(<span class="dt">mints =</span> <span class="kw">min</span>(mints), 
    <span class="dt">maxts =</span> <span class="kw">max</span>(maxts)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">as.data.frame</span>()
visits &lt;-<span class="st"> </span>visits <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(<span class="dt">visitLength =</span> <span class="kw">as.numeric</span>(<span class="kw">difftime</span>(maxts, 
    mints), <span class="dt">units =</span> <span class="st">&quot;mins&quot;</span>), <span class="dt">date =</span> <span class="kw">as.Date</span>(mints), 
    <span class="dt">tsRound =</span> <span class="kw">as.POSIXct</span>(<span class="kw">round</span>(mints, <span class="st">&quot;hours&quot;</span>)), <span class="dt">visitID =</span> <span class="kw">as.numeric</span>(visitID))
visits &lt;-<span class="st"> </span><span class="kw">merge</span>(visits, <span class="kw">select</span>(df.recvDeps, name, deployID, 
    latitude, longitude, projectID), <span class="dt">by.x =</span> <span class="st">&quot;recvDeployID&quot;</span>, 
    <span class="dt">by.y =</span> <span class="st">&quot;deployID&quot;</span>, <span class="dt">all.x =</span> <span class="ot">TRUE</span>)
## get distance travelled for the visit
visits &lt;-<span class="st"> </span>visits[<span class="kw">with</span>(visits, <span class="kw">order</span>(<span class="kw">as.numeric</span>(motusTagID, 
    mints))), ]
visits<span class="op">$</span>visit.Dist &lt;-<span class="st"> </span><span class="kw">with</span>(visits, <span class="kw">latLonDist</span>(<span class="kw">lag</span>(latitude), 
    <span class="kw">lag</span>(longitude), latitude, longitude))  ## distance for a visit is the distance it took to get there from the last station
## add sunrise info
visits &lt;-<span class="st"> </span><span class="kw">rename</span>(visits, <span class="dt">recvDeployLat =</span> latitude, 
    <span class="dt">recvDeployLon =</span> longitude, <span class="dt">ts =</span> mints)  ## need to rename, need ot fix this in function code!
<span class="co"># visits &lt;- timeToSunriset(visits, units = &#39;min&#39;)</span>
visits &lt;-<span class="st"> </span><span class="kw">rename</span>(visits, <span class="dt">recvLat =</span> recvDeployLat, <span class="dt">recvLon =</span> recvDeployLon, 
    <span class="dt">mints =</span> ts)  ## need to rename, need ot fix this in function code!
<span class="co"># day &lt;- filter(visits, mints &gt; sunrise &amp; mints &lt;</span>
<span class="co"># sunset) day$period &lt;- &#39;day&#39; night &lt;-</span>
<span class="co"># filter(visits, mints &lt; sunrise | mints &gt; sunset)</span>
<span class="co"># night$period &lt;- &#39;night&#39; visits &lt;- rbind(day,</span>
<span class="co"># night) visits$year &lt;- year(visits$mints)</span>
visits &lt;-<span class="st"> </span><span class="kw">arrange</span>(visits, recvDeployID, motusTagID, 
    mints)
<span class="co"># order site variable based on distance from exxon</span>
<span class="co"># fields first add in distance column</span>
tmp &lt;-<span class="st"> </span><span class="kw">filter</span>(dist, recvDeployName1 <span class="op">==</span><span class="st"> &quot;Exxon Fields&quot;</span>)
visits &lt;-<span class="st"> </span><span class="kw">left_join</span>(visits, <span class="kw">select</span>(tmp, recvDeployName2, 
    distance), <span class="dt">by =</span> <span class="kw">c</span>(<span class="dt">recvDeployName =</span> <span class="st">&quot;recvDeployName2&quot;</span>))
visits &lt;-<span class="st"> </span><span class="kw">rename</span>(visits, <span class="dt">distFromExxon =</span> distance)
visits<span class="op">$</span>recvDeployName &lt;-<span class="st"> </span><span class="kw">reorder</span>(visits<span class="op">$</span>recvDeployName, 
    visits<span class="op">$</span>distFromExxon)

<span class="kw">write.csv</span>(visits, <span class="st">&quot;./data/visits.csv&quot;</span>)

<span class="co"># visit length summarized by tagID and receiver</span>
visits.tag &lt;-<span class="st"> </span>visits <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(year, recvDeployName, 
    motusTagID, mfgID) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">summarize</span>(<span class="dt">meanLength =</span> <span class="kw">mean</span>(visitLength), 
    <span class="dt">totVisits =</span> <span class="kw">length</span>(visitLength)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(year, 
    recvDeployName, motusTagID, totVisits)
<span class="kw">write.csv</span>(visits.tag, <span class="st">&quot;./data/visits_tag.csv&quot;</span>)

<span class="co"># visit length summarized by receiver</span>
visits.recv &lt;-<span class="st"> </span><span class="kw">filter</span>(visits.tag) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">group_by</span>(year, 
    recvDeployName) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">summarize</span>(<span class="dt">meanLength =</span> <span class="kw">mean</span>(meanLength), 
    <span class="dt">meanVisits =</span> <span class="kw">mean</span>(totVisits)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">arrange</span>(year, 
    recvDeployName)
<span class="kw">write.csv</span>(visits.recv, <span class="st">&quot;./data/visits_recv.csv&quot;</span>)</code></pre></div>
<p>Get dataframe of antenna bearings</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get antenna metadata</span>
tbl.antDeps &lt;-<span class="st"> </span><span class="kw">tbl</span>(sql.motus, <span class="st">&quot;antDeps&quot;</span>)
df.antDeps &lt;-<span class="st"> </span>tbl.antDeps <span class="op">%&gt;%</span><span class="st"> </span>collect <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">as.data.frame</span>()
<span class="co"># merge with receiver metadata</span>
df.antDeps &lt;-<span class="st"> </span><span class="kw">left_join</span>(<span class="kw">select</span>(df.antDeps, deployID, 
    antennaType, bearing), <span class="kw">select</span>(df.recvDeps, deployID, 
    name, latitude, longitude, tsStart, tsEnd), <span class="dt">by =</span> <span class="st">&quot;deployID&quot;</span>)
<span class="co"># keep only relevant receivers</span>
deps &lt;-<span class="st"> </span><span class="kw">unique</span>(df.recvDepsCombined<span class="op">$</span>recvDeployName)
df.antDeps &lt;-<span class="st"> </span><span class="kw">filter</span>(df.antDeps, name <span class="op">%in%</span><span class="st"> </span>deps)
df.antDeps &lt;-<span class="st"> </span><span class="kw">rename</span>(df.antDeps, <span class="dt">recvDeployName =</span> <span class="st">&quot;name&quot;</span>, 
    <span class="dt">antBearing =</span> <span class="st">&quot;bearing&quot;</span>, <span class="dt">recvDeployID =</span> <span class="st">&quot;deployID&quot;</span>)</code></pre></div>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="DownloadingData.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="Results.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "section"
}
});
});
</script>

</body>

</html>
