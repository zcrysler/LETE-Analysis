# Downloading and Accessing Data {#DownloadingData}
```{r tidyr1, echo = FALSE, message = FALSE, warning = FALSE}

library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=50), tidy = TRUE)

```

Detailed instructions for accessing and understanding data can be found in the Motus R Book, available [here](https://motus.org/MotusRBook/).

## Loading Packages
In order to download data and complete the analysis you will need a number of packages, if you do not already have them installed, follow the instructions below
```{r installPackages, eval = FALSE}
# Install devtools to allow download of Motus R packages
install.packages("devtools")

# Install motus for data download, data manipulation, visualization and analysis
install_github("MotusWTS/motus")

# install motusClient for data download
install_github("MotusWTS/motusClient")

# install packages for analysis
install.packages("ggmap")
install.packages("tidyr")
install.packages("gridExtra")
install.packages("ggplot2")
install.packages("viridis")
install.packages("knitr")
install.packages("pander")
```
Once packages are installed, load them into your project
```{r loadPackages, warning = FALSE, message = FALSE}
# load motus package
library(motus)
```

## Data Download - project 132
Downloading data from Motus requires you to enter your Motus username and password, you will only have access to data for projects to which you are registered. To register with Motus visit [https://motus.org/](https://motus.org/). 

To download data for the **first time** to your working directory:

```{r firstDownload, eval = FALSE}
proj.num <- 132
sql.motus <- tagme(projRecv = proj.num, new = TRUE, update = TRUE)
```

To update an existing sql.motus file to your working directory:
```{r dataUpdate, eval = FALSE}
proj.num <- 132
sql.motus <- tagme(projRecv = proj.num, new = FALSE, update = TRUE)
```

```{r callData, echo = FALSE}
proj.num <- 132
sql.motus <- tagme(projRecv = proj.num, new = FALSE, update = FALSE)
```

## Accessing Data
To analyze data, we'll convert the sql data file into a flat file, and only keep relevant columns and Least Tern tags. At the same time we make a new column for receiver latitute and longitude consisting of the gps latitude if available, infilled with the deployment latitude if gps is not available.
```{r flatFile, warning = FALSE}
tbl.alltags <- tbl(sql.motus, "alltags") # convert sql file to a tbl
df.alltags <- tbl.alltags %>% 
  mutate(recvLat = if_else((is.na(gpsLat)|gpsLat == 0), # create new lat/lon variables
                           recvDeployLat, gpsLat), 
         recvLon = if_else((is.na(gpsLon)|gpsLon == 0), 
                           recvDeployLon, gpsLon)) %>% 
  #remove unecessary columns
  select(-ambigID, -tagProjID, -sigsd, -noise, -freq, -freqsd, -slop, -burstSlop, 
         -done, -bootnum, -tagType, -codeSet, -mfg, -tagModel, -tagLifespan, 
         -nomFreq, -pulseLen, -markerNumber, -markerType, -tagDeployAlt, 
         -tagDeployComments, -fullID, -recvDeployAlt, -antHeight, -speciesFR, 
         -speciesSci, -speciesGroup, -tagProjName, gpsAlt, recvSiteName) %>%  
  filter(speciesEN == "Least Tern") %>% # keep only LETE
  collect() %>% 
  as.data.frame %>% # convert tbl to data.frame
  # convert times to datetime
  mutate(ts = as_datetime(ts, tz = "UTC", origin = "1970-01-01"),
         tagDeployStart = as_datetime(tagDeployStart, tz = "UTC", origin = "1970-01-01"),
         tagDeployEnd = as_datetime(tagDeployEnd, tz = "UTC", origin = "1970-01-01"))

```

## Cleaning Data
Projects with receivers in the tagging area are 31, 65, 120, and 132, so we will begin by keeping all detections for receivers registered to those projects. For all other projects we'll remove any detections with a runLen < 2 as these are likely false positives. Each time we identify a false positive we'll create a block, at the end of our cleaning process we'll add all the false positive blocks together to create a single filter to apply to all the data.

First, let's remove detections outside tagging area with a runLen of 2:
```{r 2017InitialFilter}
# create list of projects with receivers outside the tagging area
nonTaggingLocs <- unique(filter(df.alltags, !(recvProjID %in% c(31, 65, 120, 132)))$recvProjID)
lete17 <- filter(df.alltags, year(ts) == 2017, # filter to only 2017 detections
                 !(recvProjID %in% nonTaggingLocs & runLen == 2)) %>% 
  # remove detections with a runLen < 2 for stations outside tagging area
  arrange(motusTagID, ts)

# create our first filter block
df.block.0 <- filter(df.alltags, year(ts) == 2017, recvProjID %in% nonTaggingLocs & runLen == 2)
```

Next, we'll start plotting detections to search for other false positives while creating more blocks for our final filter. We'll start with our 2017 detections by making a simple plot of all tags over time by latitude, while we're doing that we'll create a custom theme that we can apply to all plots.
```{r 2017filterPlots1}
# Create ggplot theme
th <- theme_bw() + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
                         plot.title = element_text(hjust = 0.5))
# plot all tags by latitude
ggplot(lete17, aes(ts, recvLat)) + geom_point() + geom_path() + facet_wrap(~motusTagID) + th
```

Our first step will be to remove tags that were never detected at the breeding site, these are **23220**, **23221**, and **23222**.
```{r 2017filterPlots2}
# remove tags 23220, 23221, 23222 and create a block
lete17 <- filter(lete17, !(motusTagID %in% c(23220, 23221, 23222)))
df.block.1 <- filter(df.alltags, year(ts) == 2017 & motusTagID %in% c(23220, 23221, 23222))
```

Now let's take a closer look at tags that were detected outside breeding area: **23212, 23214, 23216, 23219, 23223, 23225, 23226, 23227, 23270**. First we'll plot the tags, and then look at the run lengths for any detection with a runLen < 5:
```{r 2017filterPlots3}
ggplot(filter(lete17, motusTagID %in% c(23212, 23214, 23216, 23219, 23223, 23225, 23226, 23227, 23270)), aes(ts, recvLat)) + geom_point() + geom_path() + facet_wrap(~motusTagID) + th
# examining runLen < 5
filter(lete17, motusTagID %in% c(23212, 23214, 23216, 23219, 23223, 23225, 23226, 23227, 23270), runLen <5) %>% group_by(recvDeployName, runLen) %>% summarize(n = length(motusTagID)) %>% as.data.frame() %>% arrange(runLen, n)
```

Stations that stand out as having a large number of runLen = 3, far outside the tagging area include: *Koffler*, *Waggoners Gap*, *Burntpoint*, and *Los Vientos Forest*. These are likely sites with a large amount of background radio noise leading to increased levels of false positives. Let's look at a few examples before removing detections at these sites from our data.

For **tag 23216**, given the amount of time and distance between detections at *RTNJ* and *Exxon Fields*, and between *Koffler* and *Exxon Fields*, these are not biologically possible flights. We will therefore remove these detections:
```{r 2017filterPlots4}
# motusTagID 23216
ggplot(filter(lete17, motusTagID == 23216, ts > as.POSIXct("2017-06-26")), aes(ts, recvLat)) + geom_point(aes(col = recvDeployName)) + geom_path() + th
```

For **tag 23270**, it again appears there are clear false positives that can be removed at *Koffler*, *Los Vientos Forest*, *Drasher*, and *Waggoners Gap*. We will therefore remove these detections:
```{r 2017filterPlots5}
# motusTagID 23270
ggplot(filter(lete17, motusTagID == 23270), aes(ts, recvLat)) + geom_point(aes(col = recvDeployName)) + geom_path() + th
```

Let's create a filter block to remove these problem sites with high amounts of short runLen's:
```{r 2017filterPlots6}
df.block.2 <- filter(df.alltags, year(ts) == 2017, recvDeployName %in% c("Drasher", "RTNJ","Koffler", "Waggoners Gap", "Burntpoint", "Los Vientos Forest"))

```

Removing the sites with a high number of low runLen's results in much cleaner plots:
```{r 2017filterPlots7}
lete17 <- filter(lete17, !(recvDeployName %in% c("Drasher", "RTNJ","Koffler", "Waggoners Gap", "Burntpoint", "Los Vientos Forest")))
ggplot(filter(lete17, motusTagID %in% c(23212, 23214, 23216, 23219, 23223, 23225, 23226, 23227, 23270)), aes(ts, recvLat)) + geom_point() + geom_path() + facet_wrap(~motusTagID) + th
```

Lets examine the remaining tags with questionable detections: **23219, 23225, 23227**:
```{r 2017filterPlots8}
ggplot(filter(lete17, motusTagID %in% c(23219, 23225, 23227)), aes(ts, recvLat)) + geom_point(aes(col = recvDeployName)) + geom_path() + facet_grid(motusTagID~.) + th
```

We'll go through each tag individually, and then create block filters at the end.

**Tag 23219**: Detections at Rockport Bay Education Center are only runLen 2, we will remove these:
```{r 2017filterPlots9}
ggplot(filter(lete17, motusTagID == 23219, ts > as.POSIXct("2017-06-18")), aes(ts, sig)) + geom_point(aes(col = recvDeployName)) + geom_path() + facet_wrap(~motusTagID) + th
```

**Tag 23225**: detections at Peveto Woods are only runLen 2, we will remove these:
```{r 2017filterPlots10}
ggplot(filter(lete17, motusTagID == 23225, ts > as.POSIXct("2017-07-02")), aes(ts, sig)) + geom_point(aes(col = recvDeployName)) + geom_path() + facet_wrap(~motusTagID) + th
```

**Tag 23227**: all detections after June 15 are of runLen 2, except for detections at Swallowtail which are too far away to be legitimate detections so we'll remove these.
```{r 2017filterPlots11}
ggplot(filter(lete17, motusTagID == 23227), aes(ts, sig)) + geom_point(aes(col = as.factor(runLen))) + geom_path() + facet_wrap(~motusTagID) + th
```

Now let's create filter blocks for those 3 tags:
```{r 2017filterPlots12}
df.block.3 <- filter(df.alltags, year(ts) == 2017, motusTagID == 23219 & recvDeployName == "Rockport Bay Education Center")
df.block.4 <- filter(df.alltags, year(ts) == 2017, motusTagID == 23225 & recvDeployName == "Peveto Woods")
df.block.5 <- filter(df.alltags, year(ts) == 2017, motusTagID == 23227 & ts > as.POSIXct("2017-06-15"))
```

Now lets do the same with our 2018 data, starting by removing detections from stations outside the tagging area with a runLen < 2:
```{r 2018InitialFilter}
# create list of projects with receivers outside the tagging area
lete18 <- filter(df.alltags, year(ts) == 2018, # filter to only 2018 detections
                 !(recvProjID %in% nonTaggingLocs & runLen == 2)) %>% # remove detections with a runLen < 2 for stations outside tagging area
  arrange(motusTagID, ts)
# create our first filter block
df.block.6 <- filter(df.alltags, year(ts) == 2018, recvProjID %in% nonTaggingLocs & runLen == 2)
```

Next, we'll start plotting to search for other false positives while creating more blocks for our final filter.

Plot all tags by latitude:
```{r 2018filterPlots1}
ggplot(lete18, aes(ts, recvLat)) + geom_point() + geom_path() + facet_wrap(~motusTagID) + th
```

Remove tags that were never detected at the breeding site: **28614**
```{r 2018filterPlots2}
lete18 <- filter(lete18, !(motusTagID == 28614))
df.block.7 <- filter(df.alltags, year(ts) == 2018, motusTagID == 28614)
```

Now we look closer at tags that were detected outside breeding area: **28520, 28524, 28525, 28531, 28594, 28600**
```{r 2018filterPlots3}
ggplot(filter(lete18, motusTagID %in% c(28520, 28524, 28525, 28531, 28594, 28600)), aes(ts, recvLat)) + geom_point() + geom_path() + facet_wrap(~motusTagID) + th
```
Again, we'll look closer at runLen for these detections
```{r 2018filterPlots4}
filter(lete18, motusTagID %in% c(28520, 28524, 28525, 28531, 28594, 28600), runLen <5) %>% group_by(recvDeployName, runLen) %>% summarize(n = length(motusTagID)) %>% as.data.frame() %>% arrange(runLen, n)
```
Stations that stand out as having a large number of runLen = 3, far outside the tagging area include:*D'Estimauville*, and as in 2017 *Koffler.* These are likely sites with a large amount of background radio noise leading to increased levels of false positives. Let's go through each of these 6 tags individually to remove false positives.

**Tag 28520**: The detections at *D'Estimauville* in Quebec are not biologically possible given the timing, and was also flagged as a noisy site, we will therefore remove these detections at the end.
```{r 2018filterPlots5}
ggplot(filter(lete18, motusTagID == 28520), aes(ts, recvLat)) + geom_point(aes(col = recvDeployName)) + geom_path() + th
```

**Tag 28524**: Given the amount of time and distance between detections at *Koffler* and *Exxon Fields*, and between *D'Estimauville* and *Exxon Fields*, these are not biologically possible flights, they were also flagged as noisy stations. The detections at Stutchbury and Curries are of runLen 3, and occur in Ontario and Pennsylvania respectively. We will therefore remove these detections at the end.
```{r 2018filterPlots6}
ggplot(filter(lete18, motusTagID == 28524), aes(ts, recvLat)) + geom_point(aes(col = recvDeployName)) + geom_path() + th
```

**Tag 28525**: Just as with tag 28520, the detection at *D'Estimauville* will be removed.
```{r 2018filterPlots7}
ggplot(filter(lete18, motusTagID == 28525), aes(ts, recvLat)) + geom_point(aes(col = recvDeployName)) + geom_path() + th
```

**Tag 28531**: Again, it is unlikely that this tag was in Ontario and Quebec in June so we will remove detections at *Koffler*, *Old Cut*, and *D'Estimauville*.
```{r 2018filterPlots8}
ggplot(filter(lete18, motusTagID == 28531), aes(ts, recvLat)) + geom_point(aes(col = recvDeployName)) + geom_path() + th
```

**Tag 28594**: Again, it is unlikely that this tag was in Ontario, Pennsylvania or Nova Scotia, and all runLen are 3, so we will remove detections at *BPLH*, *Drasher*, and *Old Cut*.
```{r 2018filterPlots9}
ggplot(filter(lete18, motusTagID == 28594), aes(ts, recvLat)) + geom_point(aes(col = recvDeployName)) + geom_path() + th
```

**Tag 28600**: Koffler and D'Estimauville once again appear problematic and will be removed.
```{r 2018filterPlots10}
ggplot(filter(lete18, motusTagID == 28600), aes(ts, recvLat)) + geom_point(aes(col = recvDeployName)) + geom_path() + th
```

Since all false positives in these cases are for the same stations, we'll apply one filter to remove them all:
```{r 2018filterPlots11}
df.block.8 <- filter(df.alltags, year(ts) == 2018, recvDeployName %in% c("D'Estimauville", "Koffler", "Stutchbury", "Curries", "Old Cut", "BPLH", "Drasher"))
```

Let's see what the plot looks like after emoving these detections:
```{r 2018filterPlots12}
lete18 <- filter(lete18, !(recvDeployName %in% c("D'Estimauville", "Koffler", "Stutchbury", "Curries", "Old Cut", "BPLH", "Drasher")))
ggplot(filter(lete18, motusTagID %in% c(28520, 28524, 28525, 28531, 28594, 28600)), aes(ts, recvLat)) + geom_point() + geom_path() + facet_wrap(~motusTagID) + th
```

Now that we're happy with our filters, we can save a custom filter for all our data combined. The Motus R package offers functionalities to save your filters directly within your .motus file. Once they're saved in your database, you can do the type of left_join as below without having to rely on dataframes or an RDS file to store your data. More info can be found in [Appendix D](https://motus.org/MotusRBook/appendixD.html) of the Motus R Book.
```{r finalFilter, warning = FALSE}
# Combine our df.blocks into a single data frame, and apply a probability of 0 for filtered records.
df.block.all <- bind_rows(df.block.0, df.block.1, df.block.2, df.block.3, df.block.4, df.block.5, df.block.6, df.block.7, df.block.8) %>% mutate(probability = 0)

# Create a new filter with the name filtFalsePos and populate it with df.block.all
tbl.filter = writeRunsFilter(sql.motus, "filtFalsePos", 
                             df = df.block.all, delete = TRUE)

# Obtain a table object where the filtered records from tbl.filter have been removed
tbl.alltags.sub <- left_join(tbl.alltags, tbl.filter, 
    by = c("runID", "motusTagID")) %>% mutate(probability = ifelse(is.na(probability), 
    1, probability)) %>% filter(probability > 0)



```











